In computer science, graph traversal is the problem of visiting all the nodes in a graph in a particular manner, updating and/or checking their values along the way. Tree traversal is a special case of graph traversal. Unlike tree traversal, graph traversal may require that some nodes be visited more than once, since it is not necessarily known before transitioning to a node that it has already been explored. As graphs become more dense, this redundancy becomes more prevalent, causing computation time to increase; as graphs become more sparse, the opposite holds true. Thus, it is usually necessary to remember which nodes have already been explored by the algorithm, so that nodes are revisited as infrequently as possible (or in the worst case, to prevent the traversal from continuing indefinitely). This may be accomplished by associating each node of the graph with a "color" or "visitation" state during the traversal, which is then checked and updated as the algorithm visits each node. If the node has already been visited, it is ignored and the path is pursued no further; otherwise, the algorithm checks/updates the node and continues down its current path. Several special cases of graphs imply the visitation of other nodes in their structure, and thus do not require that visitation be explicitly recorded during the traversal. An important example of this is a tree, during a traversal of which it may be assumed that all "ancestor" nodes of the current node (and others depending on the algorithm) have already been visited. Both the depth-first and breadth-first graph searches are adaptations of tree-based algorithms, distinguished primarily by the lack of a structurally determined "root" node and the addition of a data structure to record the traversal's visitation state. Note: If each node in a graph is to be traversed by a tree-based algorithm (such as DFS or BFS), then the algorithm must be called at least once for each entirely distinct subgraph of the graph. This is easily accomplished by iterating through all the nodes of the graph, performing the algorithm on each node that is still unvisited when examined. A depth-first search (DFS) is an algorithm for traversing a finite graph. DFS visits the child nodes before visiting the sibling nodes; that is, it traverses the depth of any particular path before exploring its breadth. A stack (often the program's call stack via recursion) is generally used when implementing the algorithm. The algorithm begins with a chosen "root" node; it then iteratively transitions from the current node to an adjacent, unvisited node, until it can no longer find an unexplored node to transition to from its current location. The algorithm then backtracks along previously visited nodes, until it finds a node connected to yet more uncharted territory. It will then proceed down the new path as it had before, backtracking as it encounters dead-ends, and ending only when the algorithm has backtracked past the original "root" node from the very first step. DFS is the basis for many graph-related algorithms, including topological sorts and planarity testing. = Input: A graph G and a vertex v of G Output: A labeling of the edges in the connected component of v as discovery edges and back edges 1 procedure DFS(G,v): 2 label v as explored 3 for all edges e in G.incidentEdges(v) do 4 if edge e is unexplored then 5 w G.adjacentVertex(v,e) 6 if vertex w is unexplored then 7 label e as a discovery edge 8 recursively call DFS(G,w) 9 else 10 label e as a back edge A breadth-first search (BFS) is another technique for traversing a finite graph. BFS visits the neighbor nodes before visiting the child nodes, and a queue is used in the search process. This algorithm is often used to find the shortest path from one node to another. = Input: A graph G and a root v of G Output: The node closest to v in G satisfying some conditions, or null if no such a node exists in G 1 procedure BFS(G,v): 2 create a queue Q 3 enqueue v onto Q 4 mark v 5 while Q is not empty: 6 t Q.dequeue() 7 if t is what we are looking for: 8 return t 9 for all edges e in G.adjacentEdges(t) do 12 o G.adjacentVertex(t,e) 13 if o is not marked: 14 mark o 15 enqueue o onto Q 16 return null Breadth-first search can be used to solve many problems in graph theory, for example: Finding all nodes within one connected component Copying Collection, Cheney's algorithm Finding the shortest path between two nodes u and v (with path length measured by number of edges) Testing a graph for bipartiteness (Reverse) CuthillMcKee mesh numbering FordFulkerson method for computing the maximum flow in a flow network Serialization/Deserialization of a binary tree vs serialization in sorted order, allows the tree to be re-constructed in an efficient manner. Maze generation algorithms The flood fill algorithm for marking contiguous regions of a two dimensional image or n-dimensional array The analysis of networks and relationships The problem of graph exploration can be seen as a variant of graph traversal. It is an online problem, meaning that the information about the graph is only revealed during the runtime of the algorithm. A common model is as follows: Given a connected graph G = (V, E) with non-negative edge weights. The algorithm starts at some node, and knows all incident outgoing edges and the nodes at the end of these edges - but not more. When a new node is visited, then again all incident outgoing edges and the nodes at the end of the edges are known. The goal is to visit all n nodes and return to the starting node, but the sum of the weights of the tour should be as small as possible. The problem can also be understood as a specific version of the Travelling salesman problem, where the salesman has to discover the graph on the go. For general graphs, the best known algorithms for both undirected and directed graphs is a simple greedy algorithm: In the undirected case, the greedy tour is at most O(ln n)-times longer than an optimal tour. The best lower bound known for any deterministic online algorithm is 2.5-. In the directed case, the greedy tour is at most (n-1)-times longer than an optimal tour. This matches the lower bound of (n-1). 