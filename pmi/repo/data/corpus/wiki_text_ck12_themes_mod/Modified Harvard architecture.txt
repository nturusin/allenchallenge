The Modified Harvard architecture is a variation of the Harvard computer architecture that allows the contents of the instruction memory to be accessed as if it were data. Most modern computers that are documented as Harvard architecture are, in fact, Modified Harvard architecture. The original Harvard architecture computer, the Harvard Mark I, employed entirely separate memory systems to store instructions and data. The CPU fetched the next instruction and loaded or stored data simultaneously and independently. This is in contrast to a Von Neumann architecture computer, in which both instructions and data are stored in the same memory system and (without the complexity of a CPU cache) must be accessed in turn. The physical separation of instruction and data memory is sometimes held to be the distinguishing feature of modern Harvard architecture computers. With microcontrollers (entire computer systems integrated onto single chips), the use of different memory technologies for instructions (e.g. flash memory) and data (typically read/write memory) in von Neumann machines is becoming popular. The true distinction of a Harvard machine is that instruction and data memory occupy different address spaces. In other words, a memory address does not uniquely identify a storage location (as it does in a Von Neumann machine); you also need to know the memory space (instruction or data) to which the address belongs. A computer with a Von Neumann architecture has the advantage over pure Harvard machines in that code can also be accessed and treated the same as data, and vice versa. This allows, for example, data to be read from disk storage into memory and then executed as code, or self-optimizing software systems using technologies such as just-in-time compilation to write machine code into their own memory and then later execute it. Another example is self-modifying code, which allows a program to modify itself. A disadvantage of these methods are issues with executable space protection, which increase the risks from malware and software defects. In addition, in these systems it is notoriously difficult to document code flow, and also can make debugging much more difficult. Accordingly, some pure Harvard machines are specialty products. Most modern computers instead implement a modified Harvard architecture. Those modifications are various ways to loosen the strict separation between code and data, while still supporting the higher performance concurrent data and instruction access of the Harvard architecture. The most common modification builds a memory hierarchy with a CPU cache separating instructions and data. This unifies all except small portions of the data and instruction address spaces, providing the von Neumann model. Most programmers never need to be aware of the fact that the processor core implements a (modified) Harvard architecture, although they benefit from its speed advantages. Only programmers who write instructions into data memory need to be aware of issues such as cache coherency. Another change preserves the "separate address space" nature of a Harvard machine, but provides special machine operations to access the contents of the instruction memory as data. Because data is not directly executable as instructions, such machines are not always viewed as "modified" Harvard architecture: Read access: initial data values can be copied from the instruction memory into the data memory when the program starts. Or, if the data is not to be modified (it might be a constant value, such as pi, or a text string), it can be accessed by the running program directly from instruction memory without taking up space in data memory (which is often at a premium). Write access: a capability for reprogramming is generally required; few computers are purely ROM-based. For example, a microcontroller usually has operations to write to the flash memory used to hold its instructions. This capability may be used for purposes including software updates and EEPROM replacement. A few Harvard architecture processors, such as the MAXQ, can execute instructions fetched from any memory segmentunlike the original Harvard processor, which can only execute instructions fetched from the program memory segment. Such processors, like other Harvard architecture processorsand unlike pure Von Neumann architecturecan read an instruction and read a data value simultaneously, if they're in separate memory segments, since the processor has (at least) two separate memory segments with independent data buses. The most obvious programmer-visible difference between this kind of modified Harvard architecture and a pure Von Neumann architecture is thatwhen executing an instruction from one memory segmentthe same memory segment cannot be simultaneously accessed as data. Three characteristics may be used to distinguish Modified Harvard machines from Harvard and Von Neumann machines: Instruction and data memories occupy different address spaces For pure Harvard machines, there is an address 'zero' in instruction space that refers to an instruction storage location and a separate address 'zero' in data space that refers to a distinct data storage location. By contrast, Von Neumann and "split cache" modified Harvard machines store both instructions and data in a single address space, so address 'zero' refers to only one thing and whether the binary pattern in that location is interpreted as an instruction or data is defined by how the program is written. However, just like pure Harvard machines, modified Harvard architectures with separate address spaces, but with instructions allowing locations in instruction space to be written or read as data, have separate addresses 'zero' for instruction and data space, so this does not distinguish pure Harvard machines from those types of modified Harvard machines. Instruction and data memories have separate hardware pathways to the central processing unit (CPU) This is the point of pure or modified Harvard machines, and why they co-exist with the more flexible and general von Neumann architecture: separate memory pathways to the CPU allow instructions to be fetched and data to be accessed at the same time, improving throughput. The pure Harvard machines have separate pathways with separate address spaces. "Split cache" modified Harvard machines have such separate access paths for CPU caches or other tightly coupled memories, but a unified address space covers the rest of the memory hierarchy. A Von Neumann processor has only that unified address space. From a programmer's point of view, a modified Harvard processor in which instruction and data memories share an address space is usually treated as a Von Neumann machine until cache coherency becomes an issue, as with self-modifying code and program loading. This can be confusing, but such issues are usually visible only to systems programmers and integrators. Other modified Harvard machines are like pure Harvard machines in this regard. Instruction and data memories may be accessed in different ways The original Harvard machine, the Mark I, stored instructions on a punched paper tape and data in electro-mechanical counters. This, however, was entirely due to the limitations of technology available at the time. Today a Harvard machine such as the PIC microcontroller might use 12-bit wide flash memory for instructions, and 8-bit wide SRAM for data. In contrast, a Von Neumann microcontroller such as an ARM7TDMI, or a modified Harvard ARM9 core, necessarily provides uniform access to flash and SRAM (as 8 bit bytes, in those cases). Outside of applications where a cacheless DSP or microcontroller is required, most modern processors have a CPU cache which partitions instruction and data. There are also processors which are Harvard machines by the most rigorous definition (that program and data memory occupy different address spaces), and are only modified in the weak sense that there are operations to read and/or write program memory as data. For example, LPM (Load Program Memory) and SPM (Store Program Memory) instructions in the Atmel AVR implement such a modification. Similar solutions are found in other microcontrollers such as the PIC and Z8Encore!, many families of digital signal processors such as the TI C55x cores, and more. Because instruction execution is still restricted to the program address space, these processors are very unlike von Neumann machines. Having separate address spaces creates certain difficulties in programming with high-level languages that do not directly support the notion that tables of read-only data might be in a different address space from normal writable data (and thus need to be read using different instructions). The C programming language can support multiple address spaces either through non-standard extensions or through the now standardized extensions to support embedded processors. 