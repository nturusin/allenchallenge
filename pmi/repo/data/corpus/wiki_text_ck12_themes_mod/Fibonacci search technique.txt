In computer science, the Fibonacci search technique is a method of searching a sorted array using a divide and conquer algorithm that narrows down possible locations with the aid of Fibonacci numbers. Compared to binary search, Fibonacci search examines locations whose addresses have lower dispersion. Therefore, when the elements being searched have non-uniform access memory storage (i.e., the time needed to access a storage location varies depending on the location previously accessed), the Fibonacci search has an advantage over binary search in slightly reducing the average time needed to access a storage location. The typical example of non-uniform access storage is that of a magnetic tape, where the time to access a particular element is proportional to its distance from the element currently under the tape's head. Note, however, that large arrays not fitting in CPU cache or even in RAM can also be considered as non-uniform access examples. Fibonacci search has a complexity of O(log(n)) (see Big O notation). Fibonacci search was first devised by Jack Kiefer (1953) as a minimax search for the maximum (minimum) of a unimodal function in an interval. Let k be defined as an element in F, the array of Fibonacci numbers. n = Fm is the array size. If the array size is not a Fibonacci number, let Fm be the smallest number in F that is greater than n. The array of Fibonacci numbers is defined where Fk+2 = Fk+1 + Fk, when k 0, F1 = 1, and F0 = 0. To test whether an item is in the list of ordered numbers, follow these steps: Set k = m. If k = 0, stop. There is no match; the item is not in the array. Compare the item against element in Fk1. If the item matches, stop. If the item is less than entry Fk1, discard the elements from positions Fk1 + 1 to n. Set k = k 1 and return to step 2. If the item is greater than entry Fk1, discard the elements from positions 1 to Fk1. Renumber the remaining elements from 1 to Fk2, set k = k 2, and return to step 2. Alternative implementation (from "Sorting and Searching" by Knuth): Given a table of records R1, R2, ..., RN whose keys are in increasing order K1 < K2 < ... < KN, the algorithm searches for a given argument K. Assume N+1 = Fk+1 Step 1. [Initialize] i Fk, p Fk-1, q Fk-2 (throughout the algorithm, p and q will be consecutive Fibonacci numbers) Step 2. [Compare] If K < Ki, go to Step 3; if K > Ki go to Step 4; and if K = Ki, the algorithm terminates successfully. Step 3. [Decrease i] If q=0, the algorithm terminates unsuccessfully. Otherwise set (i, p, q) (p, q, p - q) (which moves p and q one position back in the Fibonacci sequence); then return to Step 2 Step 4. [Increase i] If p=1, the algorithm terminates unsuccessfully. Otherwise set (i,p,q) (i + q, p - q, 2q - p) (which moves p and q two positions back in the Fibonacci sequence); and return to Step 2 