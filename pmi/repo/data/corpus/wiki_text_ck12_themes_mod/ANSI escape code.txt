In computing, ANSI escape codes (or escape sequences) are a method using in-band signaling to control the formatting, color, and other output options on video text terminals. To encode this formatting information, certain sequences of bytes are embedded into the text, which the terminal looks for and interprets as commands, not as character codes. ANSI codes were introduced in the 1970s and became widespread in the minicomputer/mainframe market by the early 1980s. They were used by the nascent bulletin board system market to offer improved displays compared to earlier systems lacking cursor movement, leading to even more widespread use. Although hardware text terminals have become increasingly rare in the 21st century, the relevance of the ANSI standard persists because most terminal emulators interpret at least some of the ANSI escape sequences in the output text. One notable exception is the win32 console component of Microsoft Windows. Almost all manufacturers of video terminals added vendor-specific escape sequences to perform operations such as placing the cursor at arbitrary positions on the screen. One example is the VT52 terminal, which allowed the cursor to be placed at an x,y location on the screen by sending the ESC character, a y character, and then two characters representing with numerical values equal to the x,y location plus 32 (thus starting at the ASCII space character and avoiding the control characters). As these sequences were different for different platforms, elaborate libraries such as termcap had to be created so programs could use the same API to work with any terminal. Most of these systems required sending numbers (such as row and column) as the binary values of the characters; for some programming languages, and for systems that did not use ASCII internally, it was often difficult or impossible to turn a number into the correct character. The ANSI standard attempted to address these problems by making a command set that all terminals would use and requiring all numeric information to be transmitted as ASCII numbers. The first standard in the series was ECMA-48, adopted in 1976. It was a continuation of a series of character coding standards, the first one being ECMA-6 from 1961, a 7-bit standard from which ASCII originates. The name "ANSI escape sequence" dates from 1981 when ANSI adopted ECMA-48 as their standard, ANSI X3.64 (and later, in 1997, withdrew it). The first popular video terminal to support these sequences was the Digital VT100, introduced in 1978. This model was very successful in the market, which sparked a variety of VT100 clones, among the earliest and most popular of which was the much more affordable Zenith Z-19 in 1979. The popularity of these gradually led to more and more software (especially bulletin board systems) assuming the escape sequences worked, leading to almost all new terminals and emulator programs supporting them. ECMA-48 has been updated several times and is currently at its 5th edition, from 1991. It is also adopted by ISO and IEC as standard ISO/IEC 6429. The widespread use of ANSI by bulletin boards and online services led to almost universal platform support by the mid 1980s. In most cases this took the form of a terminal emulator (such as xterm on Unix or the OS X Terminal or ZTerm on MacOS and many communication programs for the IBM PC), although there was increasing support in the standard text output of many operating systems. Unix and the AmigaOS all included some ANSI support in the OS, which led to widespread use of ANSI by programs running on those platforms. Unix-like operating systems could produce ANSI codes through libraries such as termcap and curses used by many pieces of software to update the display. These libraries are supposed to support non-ANSI terminals as well, but this is so rarely tested nowadays that they are unlikely to work. Many games and shell scripts (such as colored prompts) directly write the ANSI sequences and thus cannot be used on a terminal that does not interpret them. AmigaOS not only interprets ANSI code sequences for text output to the screen, the AmigaOS printer driver also interprets them (with extensions proprietary to AmigaOS) and translates them into the codes required for the particular printer that is actually attached. In spite of its popularity, ANSI codes were not universally supported. Support was not built-in on the original "classic" Mac OS, while the Atari ST used the command system adapted from the VT52 with some expansions for color support. MS-DOS 1.x did not support the ANSI or any other escape sequences. Only a few control characters (BEL, CR, LF, BS) were interpreted by the underlying BIOS, making it almost impossible to do any kind of full-screen application. Any display effects had to be done with BIOS calls, which were notoriously slow, or by directly manipulating the IBM PC hardware. DOS 2.0 introduced the ability to add a device driver for the ANSI escape sequences the de facto standard being ANSI.SYS, but others like ANSI.COM, NANSI.SYS and ANSIPLUS.EXE are used as well (these are considerably faster as they bypass the BIOS). Slowness and the fact that it was not installed by default made software rarely take advantage of it; instead, applications continued to directly manipulate the hardware to get the text display needed. ANSI.SYS and similar drivers continued to work in Windows 9x up to Windows Me, and in NT-derived systems for 16-bit legacy programs executing under the NTVDM. The Win32 console does not support ANSI escape sequences at all. Some replacements for the console window such as JP Software's TCC (formerly 4NT), Michael J. Mefford's ANSI.COM, Jason Hood's ANSICON and Maximus5's ConEmu do interpret ANSI escape sequences printed by programs. Some software internally interprets ANSI escape sequences in text being printed and translates them to calls to manipulate the color and cursor position in the command output window, to make it easier to port software using ANSI to Windows. Escape sequences start with the character ESC (ASCII decimal 27/hex 0x1B/octal 033). For two character sequences, the second character is in the range ASCII 6495 (@ to _). However, most of the sequences are more than two characters, and start with the characters ESC and [ (left bracket). This sequence is called CSI for Control Sequence Introducer (or Control Sequence Initiator). The final character of these sequences is in the range ASCII 64126 (@ to ~). There is a single-character CSI (155/0x9B /0233) as well. The ESC[ two-character sequence is more often used than the single-character alternative (for details see C0 and C1 control codes). Only the two-character sequence is recognized by devices that support just ASCII (7-bit bytes) or devices that support 8-bit bytes, but use the 0x800x9F control character range for other purposes. On terminals that use UTF-8 encoding, both forms take 2 bytes (CSI in UTF-8 is 0xC2, 0x9B) but the ESC[ sequence is clearer. Though some encodings use multiple bytes per character, the following discussion is restricted to ASCII characters, and thus assumes a single byte for each character. Note: other C0 codes besides ESC commonly BEL, BS, CR, LF, FF, TAB, VT, SO, and SI may produce similar or identical effects to some control sequences when output. ESC N = SS2 ESC O = SS3 Select a single character from one of the alternate character sets. ESC ^ = PM ESC _ = APC These each take a single string of text, terminated by ST (ESC \ ). They are ignored by xterm. ESC P = DCS Device control string, ESC ] = OSC Operating system command these are similar to CSI, but not limited to integer arguments. Because they are frequently used, in many cases BEL is an acceptable alternative to ST. E.g., in xterm, the window title can be set by: "OSC0;this is the window titleBEL" Note: pressing special keys on the keyboard, as well as outputting many xterm CSI, DCS, or OSC sequences, often produces a CSI, DCS, or OSC sequence. The general structure of most ANSI escape sequences is CSI [private mode character(s?)] n1 ; n2... [trailing intermediate character(s?)] letter. The final byte, modified by private mode characters and trailing intermediate characters, specifies the command. The numbers are optional parameters. The default value used for omitted parameters varies with the command, but is usually 1 or 0. If trailing parameters are omitted, the trailing semicolons may also be omitted. The final byte is technically any character in the range 64126 (hex 0x400x7E, ASCII @ to ~), and may be modified with leading intermediate bytes in the range 32 to 47 (hex 0x200x2F, ASCII space to /). The colon (58, hex 0x3A) is the only character not a part of the general sequence. It was left for future standardization, so any sequence containing it should be ignored. Although multiple private mode characters or trailing intermediates are permitted, there are no such known usages. If there are any leading private mode characters, the main body of the sequence could theoretically contain any order of characters in the range 4863 (hex 0x300x3F, ASCII 0 to ?) instead of a well-formed semicolon-separated list of numbers, but all known terminals are nice and just use the non-digit characters in this range as flags. Sequences are also private if the final byte is in the range 112126 (hex 0x700x7E, ASCII p~). Examples of private escape codes include the DECTCEM (DEC text cursor enable mode) shown below. It was first introduced for the VT-300 series of video terminals. The behavior of the terminal is undefined in the case where a CSI sequence contains any character outside of the range 32 to 126 (hex 0x200x7E, ASCII space~). These illegal characters are either C0 control characters (the range 031, hex 0x000x1F), character 127 (hex 0x7F, ASCII DEL), or high-ASCII characters (the range 128255, hex 0x800xFF). Possibilities for handling illegal characters in a CSI sequence include: 1. Assuming the end of the CSI sequence, ignoring it and treating further characters as data; 2. Ignoring this sequence including all future characters through the next character that would normally end a CSI sequence (anything in the range 64126 (hex 0x400x7E, ASCII@~)); or 3. Processing any control code as the terminal normally would outside of a CSI sequence before continuing to parse the rest of the sequence. Text colors (and SGR parameters in general) are manipulated using CSI n1 [;n2 [; ...]] m sequences, where each n1, n2, ... is an SGR parameter as shown above. Thus, for instance, you use codes 30+i to specify foreground color, 40+i to specify background color, where i is the number in the desired color's column header in the table below. The following examples can be used with the printf utility, where \x1b[ implements the CSI: To switch the foreground color to black, use \x1b[30m; to switch to red, use \x1b[31m; utilizing the "bold" parameter, gray would be \x1b[30;1m; to get bold red, use \x1b[31;1m. To reset colors to their defaults, use \x1b[39;49m (not supported on some terminals) (or reset all attributes with \x1b[0m). There are two other color standards CSS/HTML standard colors and X Window colors which standardize both the color names and associated RGB color values, but the escape sequence standard only specifies the color names, not RGB values. The chart below shows default RGB assignments for some common terminal programs, together with the CSS and the X Window System colors for these color names. The VGA column denotes the typical colors that are used when booting PCs and leaving them in their classical 8025 text mode. The colors are different in the EGA/VGA graphic modes. In July 2004, the blue colors of xterm changed, RGB (0,0,205) (0,0,238) for normal and (0,0,255) (92,92,255) for bright. As of 2010, old xterm versions still linger on many computers though. Xterm, GNOME Terminal and KDE's Konsole support ISO-8613-3 24-bit foreground and background color setting Quoting one of the text-files in its source-tree: ESC[ 38;2;<r>;<g>;<b> m Select RGB foreground color ESC[ 48;2;<r>;<g>;<b> m Select RGB background color In 256-color mode (ESC[38;5;<fgcode>m and ESC[48;5;<bgcode>m), the color-codes are the following: 0x00-0x07: standard colors (as in ESC [ 3037 m) 0x08-0x0F: high intensity colors (as in ESC [ 9097 m) 0x10-0xE7: 6 6 6 = 216 colors: 16 + 36 r + 6 g + b (0 r, g, b 5) 0xE8-0xFF: grayscale from black to white in 24 steps Xterm allows also to set the default foreground and background colors using ESC]10;<foreground>BEL ESC]11;<background>BEL where <foreground> and <background> are X color specifications, and BEL is the ASCII BEL character (code 7). The closing bracket instead of an opening bracket reveals that it belongs to the operating system control commands. CSI 2 J This clears the screen and, on some devices, locates the cursor to the y,x position 1,1 (upper left corner). CSI 32 m This makes text green. On MS-DOS, normally the green would be dark, dull green, so you may wish to enable Bold with the sequence CSI 1 m which would make it bright green, or combined as CSI 32 ; 1 m. MS-DOS ANSI.SYS uses the Bold state to make the character Bright; also the Blink state can be set (via INT 10, AX 1003h, BL 00h) to render the Background in the Bright mode. MS-DOS ANSI.SYS does not support SGR codes 9097 and 100107 directly. CSI 0 ; 6 8 ; "DIR" ; 13 p This reassigns the key F10 to send to the keyboard buffer the string "DIR" and ENTER, which in the DOS command line would display the contents of the current directory. (MS-DOS ANSI.SYS only) This was sometimes used for ANSI bombs. This is a private-use code (as indicated by the letter p), using a non-standard extension to include a string-valued parameter. Following the letter of the standard would consider the sequence to end at the letter D. CSI s This saves the cursor position. Using the sequence CSI u will restore it to the position. Say the current cursor position is 7(y) and 10(x). The sequence CSI s will save those two numbers. Now you can move to a different cursor position, such as 20(y) and 3(x), using the sequence CSI 20 ; 3 H or CSI 20 ; 3 f. Now if you use the sequence CSI u the cursor position will return to 7(y) and 10(x). Some terminals require the DEC sequences ESC 7 / ESC 8 instead which is more widely supported. ANSI escape codes are often used in UNIX and UNIX-like terminals to provide syntax highlighting. For example, on compatible terminals, the following list command color-codes file and directory names by type. ls --color Users can employ escape codes in their scripts by including them as part of standard output or standard error. For example, the following sed command embellishes the output of the make command by displaying lines containing words starting with "WARN" in reverse video and words starting with "ERR" in bright yellow on a dark red background (letter case is ignored). The representations of the codes are highlighted. make 2>&1 | sed -e 's/.*\bWARN. */\x1b[7m&\x1b[0m/i' -e 's/.*\bERR. */\x1b[93;41m&\x1b[0m/i' The following shell function flashes the terminal (by alternately sending reverse and normal video mode codes) until the user presses a key. flasher () { while true; do printf \\e[?5h; sleep 0.1; printf \\e[?5l; read -s -n1 -t1 && break; done; } This can be used to alert a programmer when a lengthy command terminates, such as with make ; flasher. The Linux console uses OSC P n rr gg bb to change the palette, which, if hard-coded into an application, may hang other terminals. However, appending ST will be ignored by Linux and form a proper, ignorable sequence for other terminals. On the Linux console, certain function keys generate sequences of the form CSI [ char. The CSI sequence should terminate on the [. Old versions of Terminator generate SS3 1; modifiers char when F1F4 are pressed with modifiers. The faulty behavior was copied from GNOME Terminal. xterm replies CSI row ; column R if asked for cursor position and CSI 1 ; modifiers R if the F3 key is pressed with modifiers, which collide in the case of row == 1. This can be avoided by using the ? private modifier, which will be reflected in the response. many terminals prepend ESC to any character that is typed with the alt key down. This creates ambiguity for uppercase letters and symbols @[\]^_, which would form C1 codes. Konsole generates SS3 modifiers char when F1F4 are pressed with modifiers. 