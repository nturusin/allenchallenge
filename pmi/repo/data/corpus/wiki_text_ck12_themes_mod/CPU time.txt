CPU time (or process time) is the amount of time for which a central processing unit (CPU) was used for processing instructions of a computer program or operating system, as opposed to, for example, waiting for input/output (I/O) operations or entering low-power (idle) mode. The CPU time is measured in clock ticks or seconds. Often, it is useful to measure CPU time as a percentage of the CPU's capacity, which is called the CPU usage. CPU time and CPU usage have two main uses. The first use is to quantify the overall busyness of the system. When the CPU usage is above 70%, the user may experience lag. Such high CPU usage indicates insufficient processing power. Either the CPU needs to be upgraded, or the user experience reduced, for example, by switching to lower resolution graphics or reducing animations. The second use, with the advent of multi-tasking, is to quantify how the processor is shared between computer programs. High CPU usage by a single program may indicate that it is highly demanding of processing power or that it may malfunction; for example, it has entered an infinite loop. CPU time allows to measure how much processing power a single program requires, eliminating interference, such as time executed waiting for input or being suspended to allow other programs to run. In contrast, elapsed real time (or simply real time, or wall clock time) is the time taken from the start of a computer program until the end as measured by an ordinary clock. Elapsed real time includes I/O time and all other types of waits incurred by the program. CPU time or CPU usage can be reported either for each thread, for each process or for the entire system. Moreover, depending on what exactly the CPU was doing, the reported values can be subdivided in: User time is the amount of time the CPU was busy executing code in user space. System time is the amount of time the CPU was busy executing code in kernel space. If this value is reported for a thread or process, then it represents the amount of time the kernel was doing work on behalf of the executing context, for example, after a thread issued a system call. Idle time (for the whole system only) is the amount of time the CPU was not busy, or, otherwise, the amount of time it executed the System Idle process. Idle time actually measures unused CPU capacity. Steal time (for the whole system only), on virtualized hardware, is the amount of time the operating system wanted to execute, but was not allowed to by the hypervisor. This can happen if the physical hardware runs multiple guest operating system and the hypervisor chose to allocate a CPU time slot to another one. The Unix command top provides CPU time, priority, elapsed real time, and other information for all processes and updates it in real time. The Unix command time prints CPU time and elapsed real time for a Unix process. % time nextPrimeNumber 30000007 Prime number greater than 30000007 is 30000023 0.327u 0.010s 0:01.15 28.6% 0+0k 0+0io 0pf+0w This process took a total of 0.337 seconds of CPU time, out of which 0.327 seconds was spent in user space, and the final 0.010 seconds in kernel mode on behalf of the process. Elapsed real time was 1.15 seconds. The following is the source code of the application nextPrimeNumber which was used in the above example. POSIX functions clock() and getrusage() can be used to get CPU time consumed by any process in a POSIX environment. If the process is multithreaded, the CPU time is the sum for all threads. With Linux starting from kernel 2.6.26 there is a parameter RUSAGE_THREAD which leads to resource usage statistics for the calling thread only. On multi-processor machines, a computer program can use two or more CPUs for processing using parallel processing scheduling. In such situations, the notion of total CPU time is used, which is the sum of CPU time consumed by all of the CPUs utilized by the computer program. Elapsed real time is always the same as or more than CPU time for computer programs which use only one CPU for processing. If no wait is involved for I/O or other resources, elapsed real time and CPU time are very similar. If a program uses parallel processing, total CPU time for that program would be more than its elapsed real time. (Total CPU time)/(Number of CPUs) would be same as elapsed real time if the work load is evenly distributed on each CPU and no wait is involved for I/O or other resources. Example: A software application executed on a Hexa-core processor creates three Unix processes for fulfilling the user requirement. Each of these three processes creates two threads, enumerating a total of 6 working threads. Computation is distributed evenly on the 6 independent threads. If no wait for resources is involved, total CPU time is expected to be six times the elapsed real time. 